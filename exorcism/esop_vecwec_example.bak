#include "eabc/vecWec.h"
#include "eabc/vecInt.h"
#include <string>
#include <sstream>
#include <iostream>
#include <vector>
#include <cassert>
#include <cctype>
#include <algorithm>

// Trim whitespace from both ends
static inline std::string trim(const std::string& s) {
    size_t start = s.find_first_not_of(" \t\n\r");
    size_t end = s.find_last_not_of(" \t\n\r");
    return (start == std::string::npos) ? "" : s.substr(start, end - start + 1);
}

// Parse a literal like "x2" or "!x1"
static inline int parse_literal(const std::string& lit) {
    bool neg = false;
    size_t idx = 0;
    if (lit[idx] == '!') {
        neg = true;
        ++idx;
    }
    assert(lit.substr(idx, 1) == "x");
    idx++;
    int var_idx = 0;
    while (idx < lit.size() && std::isdigit(lit[idx])) {
        var_idx = var_idx * 10 + (lit[idx] - '0');
        ++idx;
    }
    return 2 * var_idx + (neg ? 1 : 0);
}

// Parse a cube like "x0 & !x1 & x2"
static void parse_cube_to_vec(const std::string& cube, Vec_Int_t* vCube) {
    std::istringstream iss(cube);
    std::string lit;
    while (iss) {
        std::getline(iss, lit, '&');
        lit = trim(lit);
        if (!lit.empty())
            Vec_IntPush(vCube, parse_literal(lit));
    }
    // Output: for single-output ESOP, output 0 is encoded as -1 (as in EXORCISM)
    Vec_IntPush(vCube, -1);
}

// Parse a C-like ESOP string into a Vec_Wec_t*
Vec_Wec_t* parse_esop(const std::string& esop) {
    Vec_Wec_t* vEsop = Vec_WecAlloc(8); // Start with capacity 8 cubes
    std::istringstream iss(esop);
    std::string cube;
    while (std::getline(iss, cube, '^')) {
        // Remove parentheses and whitespace
        cube.erase(std::remove(cube.begin(), cube.end(), '('), cube.end());
        cube.erase(std::remove(cube.begin(), cube.end(), ')'), cube.end());
        cube = trim(cube);
        if (cube.empty()) continue;
        Vec_Int_t* vCube = Vec_WecPushLevel(vEsop);  // allocate new level
        parse_cube_to_vec(cube, vCube);
    }
    return vEsop;
}

// Print the contents of a Vec_Wec_t for inspection
void print_vecwec(Vec_Wec_t* vEsop) {
    for (int i = 0; i < vEsop->nSize; ++i) {
        Vec_Int_t* vCube = (Vec_Int_t*)((char*)vEsop->pArray + i * sizeof(Vec_Int_t));
        std::cout << "Cube " << i << ": [";
        for (int j = 0; j < vCube->nSize; ++j) {
            std::cout << vCube->pArray[j];
            if (j < vCube->nSize - 1)
                std::cout << ", ";
        }
        std::cout << "]" << std::endl;
    }
}

int main() {
    std::string esop_str = "(x0 & !x1 & x2) ^ (!x0 & x1 & !x2) ^ (x1 & x2)";
    Vec_Wec_t* vEsop = parse_esop(esop_str);

    // Print out the result
    print_vecwec(vEsop);

    // Cleanup: free vEsop if your API provides a function for this
    // Vec_WecFree(vEsop); // Uncomment if available

    return 0;
} 
