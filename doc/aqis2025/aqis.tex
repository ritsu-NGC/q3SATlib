%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Example of \TeX Format for AQIS Pre-Proceedings
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper]{article}
\usepackage{aqis}
\usepackage{float}
\usepackage{cite}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{amsmath,amssymb,amsfonts,amstext}
% \usepackage{algorithmic}
\usepackage[dvipdfmx]{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{colortbl}
\usepackage[T1]{fontenc}
\usepackage{mdframed}
\usepackage{algorithm, algpseudocode} % texlive-science
\usepackage[braket, qm]{qcircuit}
\usepackage{newtxtext}
\usepackage[normalem]{ulem}

\usepackage{nameref}
\usepackage[braket, qm]{qcircuit}
\usepackage{tikz}
%
\input{img/defs}

%\newcommand{\sublabel}[1]{\protected@edef\@currentlabel{\thefigure(\thesubfigure)}\label{#1}}

\makeatletter
\newcommand{\sublabel}[1]{\protected@edef\@currentlabel{\thefigure(\thesubfigure)}\label{#1}}
\makeatother
\captionsetup{subrefformat=parens}
\algrenewcommand\algorithmicindent{0.5em}%
%\newtheorem{definition}{Definition}
%\newtheorem{example}{Example}
\newcommand{\thickhline}{%
    \noalign {\ifnum 0=`}\fi \hrule height 1pt
    \futurelet \reserved@a \@xhline
}
%\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
%    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\newcommand{\figcaption}[1]{\def\@captype{figure}\caption{#1}}
\newcommand{\tblcaption}[1]{\def\@captype{table}\caption{#1}}

\newcommand{\Del}[1]{\textcolor{red}{\sout{#1}}}
\newcommand{\Add}[1]{\textcolor{blue}{\emph{#1}}}

\newcount\NGCcolor
\NGCcolor=1
%\NGCcolor=0
\ifnum\NGCcolor<1
  \newcommand{\redout}[1]{\textcolor{red}{\bf #1}}
  \newcommand{\blueout}[1]{\textcolor{blue}{\bf #1}}
  \newcommand{\greenout}[1]{\textcolor{green}{\bf #1}}
  \newcommand{\cyannout}[1]{\textcolor{cyan}{\bf #1}}
  \newcommand{\magentaout}[1]{\textcolor{magenta}{\bf #1}}
  \newcommand{\yellowout}[1]{\textcolor{yellow}{\bf #1}}
\else
  \newcommand{\redout}[1]{#1}
  \newcommand{\blueout}[1]{#1}
  \newcommand{\greenout}[1]{#1}
  \newcommand{\cyannout}[1]{#1}
  \newcommand{\magentaout}[1]{#1}
  \newcommand{\yellowout}[1]{#1}
\fi

\begin{document}

\title{
   A T-count and T-depth optimal 3-input Boolean phase oracle library
}

\author{
  David Clarino
  \affiliation{1}
  \email{dizzy@ngc.is.ritsumei.ac.jp}
  \and
  Chitranshu Arya
   \affiliation{2}
  \email{chitranshu.arya.ug22@nsut.ac.in}
  \and
 Shigeru Yamashita
   \affiliation{1}
  \email{ger@cs.ritsumei.ac.jp}
  }
  
\address{1}{
  Ritsumeikan University, Graduate School of Information Science and Engineering
}
\address{2}{
  Netaji Subhas Institute of Technology
}


\abstract{
  Phase oracles are essential components of quantum algorithms used to implement Boolean functions in
  algorithms such as Grover's Algorithm. Previous research has shown that these can be implemented
  using the CNOT+T gate set. For three input Boolean functions, a novel form of the Boolean Fourier
  Transform can be used to calculate the CNOT+T gates that need to be used. A matroid partitioning
  inspired algorithm can then be used to optimize their T-depth. In this work, we generate phase
  oracles for all $256$ 3-input Boolean functions, which are T-count and T-depth optimized. We find
  that only about half these functions need any T-gates at all, and all such functions need 7. We
  provide an analysis of the reasons behind this, and propose some future work based on it.
}

\keywords{quantum circuit synthesis, oracles, quantum Boolean circuits, Grover's Algorithm}


\maketitle

%########### body

\section{Introduction and Preliminary Knowledge}
{\it Phase oracles} implement Boolean functions as quantum circuits that apply the phase $-1$
when the Boolean function is supposed to be true. They are common elements of algorithms such
as Grover's Algorithm.

Previous research has demonstrated that phase oracles can be implemented by circuits consisting
only of the CNOT and $T$/$T^{\dagger}$ gates (CNOT+T)~\cite{bib-amy-cnot}.
This basis set of quantum gates consists of the CNOT gate and the T-gate and $T^{\dagger}$-gate,
whose function is demonstrated in Fig.~\ref{fig-gates}, where $\omega = e^{i\frac{\pi}{4}}$.

\begin{figure}[t]
  \begin{minipage}{0.45\textwidth}
    \centering
    \scalebox{1.0}{
      \input{img/cnot}
    }
    \subcaption{CNOT-gate}
    \sublabel{fig-cnot}
  \end{minipage}
  \begin{minipage}{0.45\textwidth}
  \centering
    \scalebox{1.0} {
      \input{img/Tgate}
    }
    \subcaption{T-gate}
    \sublabel{fig-tgate}
    \scalebox{1.0} {
      \input{img/Tdgate}
    }
    \subcaption{$T^{\dagger}$-gate}
    \sublabel{fig-tdgate}
  \end{minipage}
  \caption{The CNOT and T-gates}
  \label{fig-gates}
\end{figure}

These circuits are remarkable because for the 3-input case, it is straightforward to optimize
the {\it T-count}, which is the number of T-gates and $T^{\dagger}$-gates~\cite{amy-meet-in-middle}.
Optimizing the T-count is essential for a circuit to be implemented fault-tolerantly, as
the cost of implementing the T-gate is prohibitively expensive in most fault-tolerant
encodings~\cite{bib-herr-lattice,bib-fowler-bridge}. {\it T-depth} is the longest such
string of T-gates and $T^{\dagger}$-gates in a quantum circuit. This is important because many modern
fault-tolerant encodings realize a cost savings merely by executing T-gates and $T^{\dagger}$-gates
together~\cite{bib-google-ecc}.

The 3-input case is interesting because it is the largest class of Boolean functions that can be
represented by a CNOT+T circuit. Since there are only 256 such Boolean functions on 3 qubits, and
there are possible uses for a library of such phase oracles for use in higher level synthesis

\noindent {\bf Our Contribution.} 
We generate a library of T-count and T-depth optimal circuits to be used as benchmarks. The T-count
optimality is achieved by using an adaptation of the 3-bit Boolean Fourier Transform that generates
a CNOT+T network quantum circuit, while the T-depth optimality is achieved by using the matroid partitioning
algorithm in~\cite{bib-amy-matroid}.

\section{Pseudo-Boolean Functions and the Boolean Fourier Transform}

One way to realize a Boolean AND is to implement what's called a {\it pseudo-Boolean}
representation~\cite{bib-barenco-elementary,bib-amy-cnot}, which uses a mix of
Boolean values, integer coefficients, and arithmetic to create a mapping $\{0,1\}^n \mapsto \{0,1\}$~\cite{bib-amy-rm}.

Before defining the concept mathematically, first observe Equation~\ref{eq-toff-bool} to see an example of a
pseudo-Boolean function. Here, real-valued coefficients are multiplied with Boolean functions of $x_a$, $x_b$,
and $y$, creating a real number, and those real numbers are then summed together using arithmetic operations
$+$ and $-$. Table~\ref{table-pseudo-toff} shows the values of $x_a \cdot x_b \cdot y$ with respect to
its components, where $T(f)$ is as defined in Equation~\ref{eq-toff-bool}. It can be proven by inspection of
Table~\ref{table-pseudo-toff} that the pseudo-Boolean expression in~\ref{eq-toff-bool} indeed implements
$x_a \cdot x_b \cdot y$. 
\begin{equation}
  \label{eq-toff-bool}
  \begin{aligned}
    &x_a \cdot x_b \cdot y &= &x_a + x_b + y \\\nonumber
    &&&+ 7(x_a \oplus x_b) + 7(x_a \oplus y) + 7(x_b \oplus y) \\\nonumber
    &&&+ (x_a \oplus x_b \oplus y)\\\nonumber
    &&= & (T_{x_a} + T_{x_b} + T_{y} + T_{x_a \oplus x_b} \\\nonumber
    &&&T_{x_a \oplus y} T_{x_b \oplus y} + T_{x_a \oplus x_b \oplus y})
  \end{aligned}
\end{equation}
\begin{table*}[t]
  \begin{minipage}{\textwidth}
    \begin{center}
      \scalebox{1.0} {
        \begin{tabular}{c|c|c|c|c|c|c|c|c|c|c}
          $x_a$ & $x_b$ & $y$ & $T_{x_a}$ & $T_{x_b}$ & $T_{y}$ & $T_{x_a \oplus x_b}$ & $T_{x_a \oplus y}$ & $T_{x_b \oplus y}$ & $T_{x_a \oplus x_b \oplus y}$ & $4x_a \cdot x_b \cdot y$\\\hline
          0     & 0     & 0   & 0         & 0         & 0       & 0                    & 0                  & 0                  & 0                             & 0            \\\hline
          0     & 0     & 1   & 0         & 0         & $1$   & 0                    & $7$             & $7$
                       & $1$                         & 0            \\\hline
          0     & 1     & 0   & 0         & $1$     & 0       & $7$               & $7$             & 0                  & $1$                         & 0            \\\hline
          0     & 1     & 1   & 0         & $1$     & $1$   & $7$               & 0                  & $7$             & 0                             & 0            \\\hline
          1     & 0     & 0   & $1$     & 0         & 0       & $7$               & 0                  & $7$             & $1$                         & 0            \\\hline
          1     & 0     & 1   & $1$     & 0         & $1$   & $7$               & $7$             & 0                  & 0                             & 0            \\\hline
          1     & 1     & 0   & $1$     & $1$     & 0       & 0                    & $7$             & $7$             & 0                             & 0            \\\hline
          1     & 1     & 1   & $1$     & $1$     & $1$   & 0                    & 0                  & 0                  & $1$                         & 4            \\\hline
        \end{tabular}
      }
      \caption{Truth table-like values of the pseudo-Boolean representation of $x_a \cdot x_b \cdot y$}
      \label{table-pseudo-toff}
    \end{center}
  \end{minipage}
  
\end{table*}

\begin{figure*}[t]
  \centering
  \scalebox{0.8} {
    \input{img/fig-toff-mark}
  }
  \caption{Implementing $x_a \cdot x_b \cdot y$ using CNOTs and T gates}
  \label{fig-toff-mark}
\end{figure*}


In general, a pseudo-Boolean function is a function such that
\begin{equation}
  \label{eq-pseudo-boolean}
  F(\mathbf{x}) = \sum_{\mathbf{k}} c_a \cdot f_k(\mathbf{x}), c_a \in \mathbb{R}, f_k : \{0,1\}^n \mapsto \{0,1\}
  F(\mathbf{x}) \in \{0,1\}
\end{equation}

In plain language, it is the sum of the products of Boolean functions with real valued coefficients, such that
the values of the sum are in the set of binary values $\{0,1\}$~\cite{bib-barenco-elementary}. This
representation is also often referred to in the context of the phases of quantum circuits as the
{\it phase polynomial}~\cite{bib-amy-cnot}.

Phase polynomials and pseudo-Boolean functions are important because phase polynomials can be calculated
using the {\it Boolean Fourier transform}, which is shown in Equation~\ref{eq-boolean-fourier}.
\begin{equation}
  \label{eq-boolean-fourier}
  \begin{aligned}
    f(\mathbf{x}) = \sum_{\mathbf{a} \neq 0} \hat{f}(\mathbf{a}) \cdot ( a_0 \cdot x_0 \oplus a_1 \cdot x_1 \cdots \oplus a_{n-1} \cdot x_{n-1}),\\\nonumber
    \hat{f}(\mathbf{a}) \in \mathbb{R} , a_0,a_1,\cdots a_{n-1} \in [0,1]
  \end{aligned}
\end{equation}

$\hat{f}(\mathbf{a})$ is a set of $2^{n}-1$ coefficients (one for each $\mathbf{a}$, except for the trivial
case $\mathbf{a} = 0$) associated with the pseudo-Boolean function, and
$( a_0 \cdot x_0 \oplus a_1 \cdot x_1 \cdots \oplus a_{n-1} \cdot x_{n-1}) $ are linear functions
that form a basis for the pseudo-Boolean function, and are maps $[0,1]^n \mapsto [0,1]$. 

Such a phase polynomial can be realized using a 

It is easy to see then that the $\hat{f}(\mathbf{a})$ that has the minimal number of odd multiples of $\frac{\pi}{4}
for each $\mathbf{a}$ also minimizes the T-count~\cite{bib-amy-rm}. Observe also, that the linear functions
$( a_0 \cdot x_0 \oplus a_1 \cdot x_1 \cdots \oplus a_{n-1} \cdot x_{n-1}) $ can be implemented
entirely by CNOT gates. This means that Equation~\ref{eq-boolean-fourier} can be realized entirely by
CNOT gates and phase gates, known as a {\it CNOT+T network}~\cite{bib-amy-cnot}. 

Optimizing the T-depth of such a CNOT+T network is done using the method in~\cite{bib-amy-matroid}.

\section{Phase Polynomial Calculation for the Three Qubit Case}
\label{Chap:Bool-pbool3q}

This section demonstrates how to calculate the phase polynomial for a three input Boolean function, using the
Boolean Fourier transform~\cite{bib-odonnell}. This section uses only a simplified version
of the Boolean Fourier transform introduced in~\cite{bib-odonnell}, but with notation taken from
\cite{bib-barenco-elementary} and~\cite{bib-amy-cnot}. The notation is chosen to more clearly demonstrate how
the equation may be implemented using quantum gates defined in the CNOT+T basis. 

First, the inner product to be used for the Boolean Fourier transform is defined below

\begin{equation}
  \label{eq-inner-prod}
  \langle f(\mathbf{x}) , g(\mathbf{x}) \rangle = \sum_{\mathbf{x}} \text{INNPROD}(f(\mathbf{x}),g(\mathbf{x})), \mathbf{x} \in \{0,1\}^n
\end{equation}
\begin{equation}  
  \text{INNPROD}(f(\mathbf{x}),g(\mathbf{x})) =
  \begin{cases}
    7 & \text{if $f(\mathbf{x})\neq g(\mathbf{x})$} \\
    1 & \text{if  $f(\mathbf{x})= g(\mathbf{x})$} 
  \end{cases}
\end{equation}

\cite{bib-odonnell} states that the {\it parity functions}, the set of exclusive sums of the input variables
$\chi(x_0,x_1,\cdots,x_n)$ shown in Equation~\ref{eq-bool-basis}, form an orthogonal basis with respect to the
inner product defined in Equation~\ref{eq-inner-prod}. In this equation, there is a factor of $\frac{1}{2^n}$ so
that $\langle f(\mathbf{x}), f(\mathbf{x}) \rangle = 1$, making the basis orthonormal.
\begin{equation}
  \label{eq-bool-basis}
  \begin{split}
  \chi(x_0,x_1,\cdots,x_n)_{\mathbf{a}} = a_0 \cdot x_0 \oplus a_1 \cdot x_1 \cdots \oplus a_{n-1} \cdot x_{n-1},\\
  a_0,a_1,\cdots a_{n-1} \in [0,1]
  \end{split}
\end{equation}

Because for each $\chi_{\mathbf{a}}$ and $\chi_{\mathbf{b}}$, there is
$\langle \chi_{\mathbf{a}}, \chi_{\mathbf{b}} \rangle = 0$, calculating $\hat{f}(\mathbf{a})$ for a specific
value of $\mathbf{a}$ simply involves taking the inner product of the full function $f(\mathbf{x})$ and the
basis state $\chi(\mathbf{x})_{\mathbf{a}}$ as shown in Equation~\ref{eq-fhat-prod}. This multiplication is
repeated for every value of $\mathbf{a}$ until all of $\hat{f}(\mathbf{a})$ is calculated.
\begin{equation}
  \label{eq-fhat-prod}
  \hat{f}(\mathbf{a}) = \langle f(\mathbf{x}), \chi(\mathbf{x})_{\mathbf{a}} \rangle
\end{equation}

\begin{example}
  As an example, let's try to derive the coefficients from Equation~\ref{eq-toff-bool}. Here
  $\mathbf{a} = (a_{x_a}, a_{x_b}, a_y)$.

  Because the trivial case ($\mathbf{a}= 000$) is not included, let's start with $\mathbf{a} = 100$ with
  $\chi_{100} = x_a$.
  Table~\ref{table-ex-100} enumerates its values in truth table form for convenience, as well as the
  value of each of the $(-1)^{f(\mathbf{x})} (-1)^{\chi_{001}(\mathbf{x})}$ terms in the inner product
  $\langle f(\mathbf{x}), \chi_{001} \rangle$

  \begin{table}[h]
    \begin{center}
      \begin{tabular}{c|c|c|c|c|c}
        \hline
        $x_a$ & $x_b$ & $y$ & $f(\mathbf{x})$ & $\chi_{100}$ & INNPROD($\chi_{100},f(\mathbf{x}$) \\\hline
        0 & 0 & 0 & 0 & 0 & 1\\\hline
        0 & 0 & 1 & 0 & 0 & 1\\\hline
        0 & 1 & 0 & 0 & 0 & 1\\\hline
        0 & 1 & 1 & 0 & 0 & 1\\\hline
        1 & 0 & 0 & 0 & 1 & 7\\\hline
        1 & 0 & 1 & 0 & 1 & 7\\\hline
        1 & 1 & 0 & 0 & 1 & 7\\\hline      
        1 & 1 & 1 & 1 & 1 & 1\\\hline
      \end{tabular}
      \caption{The value of $\chi_{100}$ and the inner product $\langle f(\mathbf{x}), \chi_{100} \rangle$}
      \label{table-ex-100}
    \end{center}
  \end{table}

  
  The terms in the right most column can then be summed just like in Equation~\ref{eq-inner-prod}:
  \begin{align}
      &\hat{f}(100) = &\langle f(\mathbf{x}), \chi_{100} \rangle = &( 1 + 1 + 1 + 1 - 1 - 1 - 1 + 1) \\\nonumber
      &&& = ( 2 ) = 1\nonumber\\\nonumber
  \end{align}
  This then gives:
  \begin{equation}
    f(\mathbf{x}) = x_a + \sum_{\mathbf{a} \neq 000,100} \hat{f}(\mathbf{a}) \cdot \chi_{\mathbf{a}}
  \end{equation}

  In the interest of conciseness, the rest of the calculation is omitted. But the reader can easily perform the
  rest to verify its equivalence with Equation~\ref{eq-toff-bool}.
\end{example}

The pseudo-Boolean function from Eq.~\ref{eq-toff-bool} is implemented as a circuit in Fig~\ref{fig-toff-mark}.

\section{Analysis}

We examine how Boolean functions $f:\{0,1\}^3 \to \{0,1\}$ behave under phase oracle synthesis, particularly in terms of $T$-count and $T$-depth.

\subsection{Even-Weight Functions}

Functions $f$ with an even number of satisfying assignments can be expressed as:
\[
f(x) = g(x_i, x_j \oplus x_k)
\quad \text{or} \quad 
f(x) = g(x_i \oplus x_j, x_k)
\]
for some $i,j,k$, where $g$ is a two-variable Boolean function.

Such functions can be implemented using only CNOT and S gates, which means they have $T$-count zero.

\[
\Qcircuit @C=1em @R=1em {
\lstick{x_i} & \ctrl{1} & \qw \\
\lstick{x_j} & \targ    & \gate{S} & \qw
}
\]

This circuit implements a controlled-phase for $f(x) = x_i x_j$.

\subsection{Functions with One True Assignment}

For a function $f$ such that $f(x) = 1$ for exactly one input (e.g., $f(x) = x_0 x_1 x_2$), the $T$-count is known to be 7.

Any function with an odd number of true assignments can be decomposed as:
\[
f = f_{\text{even}} \oplus f_{\text{single}}
\]
where $f_{\text{even}}$ has an even number of satisfying assignments, and $f_{\text{single}}$ has exactly one. Thus, the $T$-count of $f$ is at least 7.

\section{Conclusion}
\label{Sec:concl}

This method produces T-count and T-depth optimal 3-qubit phase oracles to implement 3-bit Boolean functions
such as those required in Grover's Algorithm. Future work involves using this library to construct arbitrary
$n$-bit phase oracles.

We find that:
\begin{itemize}
  \item Functions with even-weight truth tables can be implemented with the same cost as some $f'$ of $n-1$ variables.
  \item The synthesis cost for $n \geq 4$ grows rapidly in $T$-depth, suggesting the need for optimized decomposition.
  \item Hypothesis: functions of the form
  \[
  f(x_0,\ldots,x_n) = g(x_{i_1} \oplus x_{i_2} \oplus \cdots, x_{j_1} \oplus x_{j_2} \oplus \cdots, x_{k_1} \oplus \cdots)
  \]
  where $g$ depends on $\leq 3$ variables, can be synthesized exactly with only CNOT+T gates.
\end{itemize}

We propose an algorithm that:
\begin{enumerate}
  \item Decomposes $f$ into an ESOP expression.
  \item Reorders variables to minimize the number of terms with more than 3 variables.
  \item Maps $n \leq 3$ terms to a precomputed 3-qubit library.
  \item Synthesizes remaining $n \geq 4$ terms directly, optimizing for $T$-count and $T$-depth.
\end{enumerate}

Further work is required to address relative phase issues and mitigate exponential T-depth scaling in $n \geq 4$ synthesis.


\section*{Acknowledgments}                                                     
This work was supported by JSPS KAKENHI Grant Numbers 24K22298 and JST, CREST Grant Number JPMJCR24I4, Japan.


\bibliographystyle{plain}
\bibliography{ref}

\end{document}
% end of file
