%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Example of \TeX Format for AQIS Pre-Proceedings
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper]{article}
\usepackage{aqis}
\usepackage{float}
\usepackage{cite}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{amsmath,amssymb,amsfonts,amstext}
% \usepackage{algorithmic}
\usepackage[dvipdfmx]{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{colortbl}
\usepackage[T1]{fontenc}
\usepackage{mdframed}
\usepackage{algorithm, algpseudocode} % texlive-science
\usepackage[braket, qm]{qcircuit}
\usepackage{newtxtext}
\usepackage[normalem]{ulem}

\usepackage{nameref}
\usepackage[braket, qm]{qcircuit}
\usepackage{tikz}
%
\input{img/defs}

%\newcommand{\sublabel}[1]{\protected@edef\@currentlabel{\thefigure(\thesubfigure)}\label{#1}}

\makeatletter
\newcommand{\sublabel}[1]{\protected@edef\@currentlabel{\thefigure(\thesubfigure)}\label{#1}}
\makeatother
\captionsetup{subrefformat=parens}
\algrenewcommand\algorithmicindent{0.5em}%
%\newtheorem{definition}{Definition}
%\newtheorem{example}{Example}
\newcommand{\thickhline}{%
    \noalign {\ifnum 0=`}\fi \hrule height 1pt
    \futurelet \reserved@a \@xhline
}
%\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
%    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\newcommand{\figcaption}[1]{\def\@captype{figure}\caption{#1}}
\newcommand{\tblcaption}[1]{\def\@captype{table}\caption{#1}}

\newcommand{\Del}[1]{\textcolor{red}{\sout{#1}}}
\newcommand{\Add}[1]{\textcolor{blue}{\emph{#1}}}

\newcount\NGCcolor
\NGCcolor=1
%\NGCcolor=0
\ifnum\NGCcolor<1
  \newcommand{\redout}[1]{\textcolor{red}{\bf #1}}
  \newcommand{\blueout}[1]{\textcolor{blue}{\bf #1}}
  \newcommand{\greenout}[1]{\textcolor{green}{\bf #1}}
  \newcommand{\cyannout}[1]{\textcolor{cyan}{\bf #1}}
  \newcommand{\magentaout}[1]{\textcolor{magenta}{\bf #1}}
  \newcommand{\yellowout}[1]{\textcolor{yellow}{\bf #1}}
\else
  \newcommand{\redout}[1]{#1}
  \newcommand{\blueout}[1]{#1}
  \newcommand{\greenout}[1]{#1}
  \newcommand{\cyannout}[1]{#1}
  \newcommand{\magentaout}[1]{#1}
  \newcommand{\yellowout}[1]{#1}
\fi

\begin{document}

\title{
   A T-count and T-depth optimal 3-input Boolean phase oracle library
}

\author{
  David Clarino
  \affiliation{1}
  \email{dizzy@ngc.is.ritsumei.ac.jp}
  \and
  Chitranshu Arya
   \affiliation{2}
  \email{chitranshu.arya.ug22@nsut.ac.in}
  \and
 Shigeru Yamashita
   \affiliation{1}
  \email{ger@cs.ritsumei.ac.jp}
  }
  
\address{1}{
  Ritsumeikan University, Graduate School of Information Science and Engineering
}
\address{2}{
  Netaji Subhas Institute of Technology
}


\abstract{
  Phase oracles are essential components of quantum algorithms used to implement Boolean functions in
  algorithms such as Grover's Algorithm. Previous research has shown that these can be implemented
  using the CNOT+T gate set. For three input Boolean functions, a novel form of the Boolean Fourier
  Transform can be used to calculate the CNOT+T gates that need to be used. A matroid partitioning
  inspired algorithm can then be used to optimize their T-depth. In this work, we generate phase
  oracles for all $256$ 3-input Boolean functions, which are T-count and T-depth optimized. We find
  that only about half these functions need any T-gates at all, and all such functions need 7. We
  provide an analysis of the reasons behind this, and propose some future work based on it.
}

\keywords{quantum circuit synthesis, oracles, quantum Boolean circuits, Grover's Algorithm}


\maketitle

%########### body

\section{Introduction and Preliminary Knowledge}
{\it Phase oracles} implement Boolean functions as quantum circuits that apply the phase $-1$
when the Boolean function is supposed to be true. They are common elements of algorithms such
as Grover's Algorithm.

Previous research has demonstrated that phase oracles can be implemented by circuits consisting
only of the CNOT and $T$/$T^{\dagger}$ gates (CNOT+T)~\cite{bib-amy-cnot}.
This basis set of quantum gates consists of the CNOT gate and the T-gate and $T^{\dagger}$-gate,
whose function is demonstrated in Fig.~\ref{fig-gates}, where $\omega = e^{i\frac{\pi}{4}}$.

\begin{figure}[t]
  \begin{minipage}{0.45\linewidth}
    \centering
    \scalebox{1.0} {
      \input{img/Sgate}
    }
    \subcaption{S-gate}
    \sublabel{fig-sgate}
    \scalebox{1.0} {
      \input{img/Sdgate}
    }
    \subcaption{S$^{\dagger}$-gate}
    \sublabel{fig-sdgate}
    \scalebox{1.0}{
      \input{img/cnot}
    }
    \subcaption{CNOT-gate}
    \sublabel{fig-cnot}
  \end{minipage}
  \begin{minipage}{0.45\linewidth}
  \centering
    \scalebox{1.0} {
      \input{img/Tgate}
    }
    \subcaption{T-gate}
    \sublabel{fig-tgate}
    \scalebox{1.0} {
      \input{img/Tdgate}
    }
    \subcaption{$T^{\dagger}$-gate}
    \sublabel{fig-tdgate}
  \end{minipage}
  \caption{The CNOT and T-gates}
  \label{fig-gates}
\end{figure}

These circuits are remarkable because for the 3-input case, it is straightforward to optimize
the {\it T-count}, which is the number of T-gates and $T^{\dagger}$-gates~\cite{amy-meet-in-middle}.
Optimizing the T-count is essential for a circuit to be implemented fault-tolerantly, as
the cost of implementing the T-gate is prohibitively expensive in most fault-tolerant
encodings~\cite{bib-herr-lattice,bib-fowler-bridge}. {\it T-depth} is the longest such
string of T-gates and $T^{\dagger}$-gates in a quantum circuit. This is important because many modern
fault-tolerant encodings realize a cost savings merely by executing T-gates and $T^{\dagger}$-gates
together~\cite{bib-google-ecc}.

The 3-input case is interesting because it is the largest class of Boolean functions that can be
represented by a CNOT+T circuit. Since there are only 256 such Boolean functions on 3 qubits, and
there are possible uses for a library of such phase oracles for use in higher level synthesis

\noindent {\bf Our Contribution.} 
We generate a library of T-count and T-depth optimal circuits to be used as benchmarks. The T-count
optimality is achieved by using an adaptation of the 3-bit Boolean Fourier Transform that generates
a CNOT+T network quantum circuit, while the T-depth optimality is achieved by using the matroid partitioning
algorithm in~\cite{bib-amy-matroid}.

\section{Pseudo-Boolean Functions and the Boolean Fourier Transform}

One way to realize a Boolean AND is to implement what's called a {\it pseudo-Boolean}
representation~\cite{bib-barenco-elementary,bib-amy-cnot}, which uses a mix of
Boolean values, integer coefficients, and arithmetic to create a mapping $\{0,1\}^n \mapsto \{0,1\}$~\cite{bib-amy-rm}.

Before defining the concept mathematically, first observe Equation~\ref{eq-toff-bool} to see an example of a
pseudo-Boolean function. Here, real-valued coefficients are multiplied with Boolean functions of $x_a$, $x_b$,
and $y$, creating a real number, and those real numbers are then summed together using arithmetic operations
$+$ and $-$. Table~\ref{table-pseudo-toff} shows the values of $x_a \cdot x_b \cdot y$ with respect to
its components, where $T(f)$ is as defined in Equation~\ref{eq-toff-bool}. It can be proven by inspection of
Table~\ref{table-pseudo-toff} that the pseudo-Boolean expression in~\ref{eq-toff-bool} indeed implements
$x_a \cdot x_b \cdot y$. 
\begin{equation}
  \label{eq-toff-bool}
  \begin{aligned}
    &x_a \cdot x_b \cdot y &= &\frac{1}{4}x_a + \frac{1}{4}x_b + \frac{1}{4}y - \frac{1}{4}(x_a \oplus x_b)
    -\frac{1}{4}(x_a \oplus y) \\\nonumber
    &&&- \frac{1}{4}(x_b \oplus y) + \frac{1}{4}(x_a \oplus x_b \oplus y)\\\nonumber
    &&= &\frac{1}{4} (T_{x_a} + T_{x_b} + T_{y} + T_{x_a \oplus x_b} 
    T_{x_a \oplus y} T_{x_b \oplus y} \\\nonumber
    &&&+ T_{x_a \oplus x_b \oplus y})
  \end{aligned}
\end{equation}
\begin{table*}[h]
  \begin{minipage}{\textwidth}
    \begin{center}
      \scalebox{1.0} {
        \begin{tabular}{c|c|c|c|c|c|c|c|c|c|c}\hline
          $x_a$ & $x_b$ & $y$ & $T_{x_a}$ & $T_{x_b}$ & $T_{y}$ & $T_{x_a \oplus x_b}$ & $T_{x_a \oplus y}$ & $T_{x_b \oplus y}$ & $T_{x_a \oplus x_b \oplus y}$ & $x_a \cdot x_b \cdot y$\\\hline
          0     & 0     & 0   & 0         & 0         & 0       & 0                    & 0                  & 0                  & 0                             & 0            \\\hline
          0     & 0     & 1   & 0         & 0         & $1/4$   & 0                    & $-1/4$             & $-1/4$             & $1/4$                         & 0            \\\hline
          0     & 1     & 0   & 0         & $1/4$     & 0       & $-1/4$               & $-1/4$             & 0                  & $1/4$                         & 0            \\\hline
          0     & 1     & 1   & 0         & $1/4$     & $1/4$   & $-1/4$               & 0                  & $-1/4$             & 0                             & 0            \\\hline
          1     & 0     & 0   & $1/4$     & 0         & 0       & $-1/4$               & 0                  & $-1/4$             & $1/4$                         & 0            \\\hline
          1     & 0     & 1   & $1/4$     & 0         & $1/4$   & $-1/4$               & $-1/4$             & 0                  & 0                             & 0            \\\hline
          1     & 1     & 0   & $1/4$     & $1/4$     & 0       & 0                    & $-1/4$             & $-1/4$             & 0                             & 0            \\\hline
          1     & 1     & 1   & $1/4$     & $1/4$     & $1/4$   & 0                    & 0                  & 0                  & $1/4$                         & 1            \\\hline
        \end{tabular}
      }
      \caption{Truth table-like values of the pseudo-Boolean representation of $x_a \cdot x_b \cdot y$}
      \label{table-pseudo-toff}
    \end{center}
  \end{minipage}
\vspace{-0.5cm}
\end{table*}
\begin{figure}[t]
  \centering
  \scalebox{0.7} {
    \input{img/fig-toff-mark}
  }
  \caption{Implementing $x_a \cdot x_b \cdot y$ using CNOTs and T gates}
  \label{fig-toff-mark}
\end{figure}


In general, a pseudo-Boolean function is a function such that
\begin{equation}
  \label{eq-pseudo-boolean}
  F(\mathbf{x}) = \sum_{\mathbf{k}} c_a \cdot f_k(\mathbf{x}), c_a \in \mathbb{R}, f_k : \{0,1\}^n \mapsto \{0,1\}
  F(\mathbf{x}) \in \{0,1\}
\end{equation}

In plain language, it is the sum of the products of Boolean functions with real valued coefficients, such that
the values of the sum are in the set of binary values $\{0,1\}$~\cite{bib-barenco-elementary}. This
representation is also often referred to in the context of the phases of quantum circuits as the
{\it phase polynomial}~\cite{bib-amy-cnot}.

Phase polynomials and pseudo-Boolean functions are important because phase polynomials can be calculated
using the {\it Boolean Fourier transform}, which is shown in Equation~\ref{eq-boolean-fourier}.
\begin{equation}
  \label{eq-boolean-fourier}
  \begin{aligned}
    f(\mathbf{x}) = \sum_{\mathbf{a} \neq 0} \hat{f}(\mathbf{a}) \cdot ( a_0 \cdot x_0 \oplus a_1 \cdot x_1 \cdots \oplus a_{n-1} \cdot x_{n-1}),\\\nonumber
    \hat{f}(\mathbf{a}) \in \mathbb{R} , a_0,a_1,\cdots a_{n-1} \in [0,1]
  \end{aligned}
\end{equation}

$\hat{f}(\mathbf{a})$ is a set of $2^{n}-1$ coefficients (one for each $\mathbf{a}$, except for the trivial
case $\mathbf{a} = 0$) associated with the pseudo-Boolean function, and
$( a_0 \cdot x_0 \oplus a_1 \cdot x_1 \cdots \oplus a_{n-1} \cdot x_{n-1}) $ are linear functions
that form a basis for the pseudo-Boolean function, and are maps $[0,1]^n \mapsto [0,1]$. 

Such a phase polynomial can be realized using a CNOT+T network, as demonstrated in Fig.~\ref{fig-toff-mark}.
It is easy to see then that the $\hat{f}(\mathbf{a})$ that has the minimal number of odd multiples of $\frac{\pi}{4}$
for each $\mathbf{a}$ also minimizes the T-count~\cite{bib-amy-rm}. Optimizing the T-depth of such a CNOT+T network is
done using the method in~\cite{bib-amy-matroid}.
%% Observe also, that the linear functions
%% $( a_0 \cdot x_0 \oplus a_1 \cdot x_1 \cdots \oplus a_{n-1} \cdot x_{n-1}) $ can be implemented
%% entirely by CNOT gates. This means that Equation~\ref{eq-boolean-fourier} can be realized entirely by
%% CNOT gates and phase gates, known as a {\it CNOT+T network}~\cite{bib-amy-cnot}. 


\section{Phase Polynomial Calculation for the Three Qubit Case}
\label{Chap:Bool-pbool3q}

This section demonstrates how to calculate the phase polynomial for a three input Boolean function, using the
Boolean Fourier transform~\cite{bib-odonnell}. This section uses only a simplified version
of the Boolean Fourier transform introduced in~\cite{bib-odonnell}, but with notation taken from
\cite{bib-barenco-elementary} and~\cite{bib-amy-cnot}. The notation is chosen to more clearly demonstrate how
the equation may be implemented using quantum gates defined in the CNOT+T basis. 

First, the inner product to be used for the Boolean Fourier transform is defined below

\begin{equation}
  \label{eq-inner-prod}
  \langle f(\mathbf{x}) , g(\mathbf{x}) \rangle = \frac{1}{2^n} \sum_{\mathbf{x}} (-1)^{f(\mathbf{x})}\cdot
  (-1)^{g(\mathbf{x})}, \mathbf{x} \in \{0,1\}^n
\end{equation}
%% \begin{equation}
%%   \label{eq-inner-prod}
%%   \langle f(\mathbf{x}) , g(\mathbf{x}) \rangle = \sum_{\mathbf{x}} \text{INNPROD}(f(\mathbf{x}),g(\mathbf{x})), \mathbf{x} \in \{0,1\}^n
%% \end{equation}
%% \begin{equation}  
%%   \text{INNPROD}(f(\mathbf{x}),g(\mathbf{x})) =
%%   \begin{cases}
%%     7 & \text{if $f(\mathbf{x})\neq g(\mathbf{x})$} \\
%%     1 & \text{if  $f(\mathbf{x})= g(\mathbf{x})$} 
%%   \end{cases}
%% \end{equation}

\cite{bib-odonnell} states that the {\it parity functions}, the set of exclusive sums of the input variables
$\chi(x_0,x_1,\cdots,x_n)$ shown in Equation~\ref{eq-bool-basis}, form an orthogonal basis with respect to the
inner product defined in Equation~\ref{eq-inner-prod}. In this equation, there is a factor of $\frac{1}{2^n}$ so
that $\langle f(\mathbf{x}), f(\mathbf{x}) \rangle = 1$, making the basis orthonormal.
\begin{equation}
  \label{eq-bool-basis}
  \begin{split}
  \chi(x_0,x_1,\cdots,x_n)_{\mathbf{a}} = a_0 \cdot x_0 \oplus a_1 \cdot x_1 \cdots \oplus a_{n-1} \cdot x_{n-1},\\
  a_0,a_1,\cdots a_{n-1} \in [0,1]
  \end{split}
\end{equation}

Because for each $\chi_{\mathbf{a}}$ and $\chi_{\mathbf{b}}$, there is
$\langle \chi_{\mathbf{a}}, \chi_{\mathbf{b}} \rangle = 0$, calculating $\hat{f}(\mathbf{a})$ for a specific
value of $\mathbf{a}$ simply involves taking the inner product of the full function $f(\mathbf{x})$ and the
basis state $\chi(\mathbf{x})_{\mathbf{a}}$ as shown in Equation~\ref{eq-fhat-prod}. This multiplication is
repeated for every value of $\mathbf{a}$ until all of $\hat{f}(\mathbf{a})$ is calculated.
\begin{equation}
  \label{eq-fhat-prod}
  \hat{f}(\mathbf{a}) = \langle f(\mathbf{x}), \chi(\mathbf{x})_{\mathbf{a}} \rangle
\end{equation}

\begin{example}
  As an example, let's try to derive the coefficients from Equation~\ref{eq-toff-bool}. Here
  $\mathbf{a} = (a_{x_a}, a_{x_b}, a_y)$.

  Because the trivial case ($\mathbf{a}= 000$) is not included, let's start with $\mathbf{a} = 100$ with
  $\chi_{100} = x_a$.
  Table~\ref{table-ex-100} enumerates its values in truth table form for convenience, as well as the
  value of each of the $(-1)^{f(\mathbf{x})} (-1)^{\chi_{001}(\mathbf{x})}$ terms in the inner product
  $\langle f(\mathbf{x}), \chi_{001} \rangle$

  \begin{table}[h]
    \begin{center}
      \begin{tabular}{c|c|c|c|c|c}
        \hline
        $x_a$ & $x_b$ & $y$ & $f(\mathbf{x})$ & $\chi_{100}$ & $(-1)^{\chi_{100}(\mathbf{x})} (-1)^{f(\mathbf{x}}$ \\\hline
        0 & 0 & 0 & 0 & 0 & 1\\\hline
        0 & 0 & 1 & 0 & 0 & 1\\\hline
        0 & 1 & 0 & 0 & 0 & 1\\\hline
        0 & 1 & 1 & 0 & 0 & 1\\\hline
        1 & 0 & 0 & 0 & 1 & -1\\\hline
        1 & 0 & 1 & 0 & 1 & -1\\\hline
        1 & 1 & 0 & 0 & 1 & -1\\\hline      
        1 & 1 & 1 & 1 & 1 & 1\\\hline
      \end{tabular}
      \caption{The value of $\chi_{100}$ and the inner product $\langle f(\mathbf{x}), \chi_{100} \rangle$}
      \label{table-ex-100}
    \end{center}
    \vspace{-0.5cm}
  \end{table}
  
  The terms in the right most column can then be summed just like in Equation~\ref{eq-inner-prod}:
  \begin{align}
      &\hat{f}(100) = &\langle f(\mathbf{x}), \chi_{100} \rangle = &\frac{1}{8} ( 1 + 1 + 1 + 1 - 1 - 1 - 1 + 1) \\\nonumber
      &&& = \frac{1}{8} ( 2 ) = \frac{1}{4}\nonumber\\\nonumber
  \end{align}
  This then gives:
  \begin{equation}
    f(\mathbf{x}) = \frac{1}{4}x_a + \sum_{\mathbf{a} \neq 000,100} \hat{f}(\mathbf{a}) \cdot \chi_{\mathbf{a}}
  \end{equation}

  In the interest of conciseness, the rest of the calculation is omitted. But the reader can easily perform the
  rest to verify its equivalence with Equation~\ref{eq-toff-bool}.
\end{example}

\section{Analysis}

On analysis of the T-count and T-depth of the generated library, perhaps surprisingly, we found
that every circuit fell into two categories: {\it even-weighted} (even number of fulfilling
assignments) functions that had 0 T-count and 0 T-depth, and {\it odd-weighted} (odd number
of fulfilling assignments) functions, with a T-count of 7 and T-depth of 3. We offer an
explanation below.

\subsection{Even-Weight Functions}

Observe from Eq.~\ref{eq-inner-prod} that when $n=2$ i.e. for Boolean functions
of two variables, the coefficients are at most $1/2$, meaning all such functions
can be implemented using only CNOT and S gates, with 0 T-count. One such circuit
is displayed in Fig.~\ref{fig:phase_x1x2}.
\vspace{-0.5cm}
\begin{figure}[h]
  \centering
  \[
  \Qcircuit @C=1em @R=1em {
    \lstick{\ket{x_1}} & \gate{S} & \ctrl{1} & \qw              & \ctrl{1} &   \\
    \lstick{\ket{x_2}} & \gate{S} & \targ    & \gate{S^\dagger} & \targ    & \qw
  }
  \]
  \vspace{-0.5cm}
  \caption{Circuit that implements a phase of $x_1 \cdot x_2$.}
  \label{fig:phase_x1x2}
  \vspace{-0.5cm}
\end{figure}
Functions $f$ with an even number of satisfying assignments can be expressed as:
\[
f(x) = g(x_i, x_j \oplus x_k)
\quad \text{or} \quad 
f(x) = g(x_i \oplus x_j, x_k)
\]
for some $i,j,k$, where $g$ is a two-variable Boolean function. This can be confirmed
quickly from calculating all such 3 variable functions. They are {\it affine} with
two variable functions up to an XOR with one of the inputs or the output.

\subsection{Odd-Weight Functions}

For a function $f$ such that $f(x) = 1$ for exactly one input (e.g., $f(x) = x_0 x_1 x_2$), the $T$-count is known to be 7.

Any function with an odd number of true assignments can be decomposed as:
\[
f = f_{\text{even}} \oplus f_{\text{single}}
\]
where $f_{\text{even}}$ has an even number of satisfying assignments, and $f_{\text{single}}$ has exactly one. Thus, the
$T$-count of an odd-weighted such $f$ is 7.

\section{Conclusion}
\label{Sec:concl}

We produced T-count and T-depth optimal 3-qubit phase oracles to implement 3-bit Boolean functions
such as those required in Grover's Algorithm. Upon analyzing the produced library, we realized that
even-weighted functions required no T-gates to implement, while odd-weighted functions required at least 7.
Future work involves using this library to construct arbitrary $n$-bit phase oracles.

It informs some interesting future avenues of inquiry.
\begin{itemize}
  \item Can functions with even-weight truth tables in general be implemented with the same cost as some $f'$ of $n-1$ variables?
  \item Can functions of the form
  \[
  f(x_0,\ldots,x_n) = g(x_{i_1} \oplus x_{i_2} \oplus \cdots, x_{j_1} \oplus x_{j_2} \oplus \cdots, x_{k_1} \oplus \cdots)
  \]
  where $g$ depends on $\leq 3$ variables, be synthesized exactly with only CNOT+T gates? If so, can we use this fact to optimize
  synthesis of circuits in general by integrating usage of the library produced in this work?
\end{itemize}

While the usages of 3 variable phase oracles themselves may be limited, there could be further applications for
phase oracles of 4 or more variables by composing them. This will be interesting future research.

\section*{Acknowledgments}                                                     
This work was supported by JSPS KAKENHI Grant Numbers 24K22298 and JST, CREST Grant Number JPMJCR24I4, Japan.


\bibliographystyle{plain}
\bibliography{ref}

\end{document}
% end of file
